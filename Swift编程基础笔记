Swift编程基础
	第1课
		//基本数据类型，常量变量，类型推断，判断数据类型，输出语句，拼接字符串，注释
			import Cocoa  Cocoa是所有macOS应用程序的框架\n//基本数据类型，常量变量，类型推断，判断数据类型，输出语句，拼接字符串，注释\n//2\nvar str = "Hello, playground"\nvar a:String = "hello world"\nvar b:Int = 10\nvar c:Float = 1.2\nvar d:Double = 1.22\nvar e:Character = "A"\nprint(a)\n//3\nvar a1 = 100\nlet b1 = 45\n\n\n//4\nvar a2 = "gello"\nvar b2 = 12\n\n//5\ntype(of: a)\ntype(of: b)\ntype(of: true)\n//6\nprint(a,b,true,type(of: e))\nprint(c)\n\nprint("gdye\\ngd")\n//7\nprint( "\(b)" + "fasgafga")\nprint("f +  \(true) --  \(100)")\n//8\n//dan\n/*\n大\n    这是一行注释\n */\n
	第2节课
		类型别名：typealias dog = int  意在降低冗余的全限定类名书写
			typealias dog = Int\nvar a:dog = 10\nvar b:Int = 20\nprint(a,b)\ntypealias S = String\nlet c:S = "hello"\nvar  d:String = "world"\nprint(c+d)\n
			为 Int 类型创建别名。这样就可以在代码中的任何地方使用 Money，就像是 Int 一样
				引用数据类型
		类型转换: 类型（）和？？语法
			typealias dog = Int\nvar a:dog = 10\nvar b:Int = 20\nprint(a,b)\ntypealias S = String\nlet c:S = "hello"\nvar  d:String = "world"\nprint(c+d)\n//2  类型转换\n//基本上所有类型都能转换成字符串（基础数据类型）（不过太绝对了）\nvar a1  = 10\nprint("值等于 = \(a1)")\nprint("值等于 =" + String(a1))\nprint("值等于 =" + String(true))\nprint("值等于 =" + String(1.5))\nlet b1 = false\nprint("值等于 =" + String(b1))\n\n\nvar a2 = "hello"\nprint(Int(a2) ?? 100)\n//转换不了就取？？后面的值\nvar a22 = "10"\nprint(Int(a22))\n//Optional(10)可选类型\nprint(Int(100.5))\n//浮点转整形\n\nprint(Bool(0), Bool(1.2))\n//bool只要是非0就都是true
	第三节课
		可选类型和解析值
			import Cocoa\nvar str = "Hello, playground"\n//可选类型： var aInt？= 10\n//指的是变量或者常量可能有值也可能没有值\n//类似于Java中定义一个对象还没有一个实例，就先给这个变量设置一个空null\n// var a = nil 报错：必须申明类型\nvar a:Int? = nil//a是一个Int类型的可选类型\nvar b:Int? = 100\n//print(a)\nprint(a ?? 0)//有值就拿值没值就取？？后的0\nprint(b)\nprint(b!)//你自己明确是一个可以打印输出的类型（真实的值），就用！（叹号语法）强行解析\nvar c:String? = "hello"\nprint(c!)\nprint(Int("1000"))\n/*\n 系统不确定能不能转换成一个Int类型，所以输出Optional(1000)的可选类型\n*/\n//eg2:\nvar value:String? = "hello"//value是一个string类型的可选类型，此时明确有值为“hello”\n//value = nil//此时将value变为没有值nil\nprint(value)\n//var value1:String = "hello"\n//value1 = nil\n//print(value1)此时就出错\n/*\n if()这个括号可写可不写，为了清晰可以写上\n */\nif (value == nil) {\n    print("没有值")\n}\nelse{\n    print("value的值="  +  value!)//直接写value不行，尽管在value有值的情况下，但是value依然还是一个 ？ 可选类型，所以必须用！叹号强行解析出来\n}\n//eg3:\nvar  a2:Int? = 10\nif (a2 == nil) {\n    print("a2没有值")\n}else\n{\n    print("a2的值为 = \(a2!)")//拼接字符串语法\n    print("a2的值为 = " +  String(a2!))//先将可选类型的a2的真实值通过叹号语法解析出来，再将解析出来的值转化成string类型的值\n}\n\n\n
	第四节课
		元祖类型
			import Cocoa\n\nvar str = "Hello, playground"\n//元祖类型\n//Java就没有\n//人话：不同类型的一个数据封装☝🏻，将多个不同类型的数据封装在一起，来进行一个整体操作，\n//人话2：可以看做是一个集合，只不过可以装不同的数据类型\n//part01： 元祖的定义（一般元祖也不会封装太多值）\nvar a = (1,15.6,"hello",true)//没有明确指定a元祖的类型，系统通过类型推断出a为元祖类型\nvar b:(Int,String) = (10,"swift")//明确指出元祖b中的每一个数据的数据类型\n//元祖a，b就是最常用的两种定义方式\nprint(a)\nprint(b)\nvar c = ()//c是一个空元祖(既为申明类型也为传入参数)，可以定义也可以打印（操作）\nprint(c)\n/*\n var d:(Int) = () ；会报错，申明累元祖类型，就必传入参数\n **/\n//part02： 元祖的取值\nprint(a.0)//元祖的索引从0开始\nprint(a.3)\n//元祖的值得修改,变量元祖才可以，常量元祖不行🚫\n//变量元祖可以取值也可以改变值，常量元祖只能取值\nprint(b.1)\nb.1 =  "ios"\nprint(b.1)\n//元祖的传递，赋值\nvar a1 = a\nprint(a1)\na1.0 = 18\nprint(a1)\nprint(a)\n//元祖也是一个值传递，并不是引用传递。相当于copy了一份，并不会对原来的元祖有影响。\n\n//part03  元祖中可以对值取一个名称\nvar a3 = (name1:"Apple watch" , name2:true)\nvar a4:(name1:Int,name2:String) = (100,"i TV")//再申明元祖类型的时候也可以对类型取名称\nprint(a3)//元祖的名称会一起打印出来\nprint(a4)\nprint(a3.0)\nprint(a3.name1)//就不用索引取值了，用名称取值\n//结构体的解构赋值？？？？？？？？？\nlet (name1,name2) = ("swift",1.5)\nvar (name3,name4) = (123,true)//元祖无类型，通过类型判断来判断类型\nprint(name1)\nprint(name2)\n//元祖的解包？？？？？？？？\n//元祖的忽略\nlet (name11,_,name22) = ("swift",1.5,true)///还可以忽略其中的某一个\nprint(name11,name22)\n//元祖可以当做一个函数里面的参数，再在函数里对元祖进行一个二次修改，修改完后再将元祖进行返回，成为一个新的元祖。\n//Java中没有多返回值的情况\n//元祖可以当做一个函数里面的参数\nvar data = (name1:1,name2:"hello",name3:true)\nfunc handle(parm:(Int,String,Bool)) -> (Int,String,Bool)\n{\n    var data_temp  = parm\n    data_temp.0 = parm.0 + 1\n    data_temp.1 = parm.1  + "wprld"\n    data_temp.2 = false\n    return data_temp\n}\nprint(data)\n\nprint("-----------------------------")\nlet dara2 = handle(parm: data)\nprint(dara2)\n\n\n\n\n\n\n
	第五节课
		基础运算符
			import Cocoa\n\nvar str = "Hello, playground"\n//基础运算符\n/*\n 1 专门用语\n 2 赋值运算符\n 3 算术运算符\n 3.1 余数运算符\n 3.2 一元减号运算符\n 3.3 一元加号运算符\n 4 组合赋值符号\n 5 比较运算符\n 6 三元条件运算符\n 7 合并空值运算符\n 8 区间运算符\n 8.1 闭区间运算符\n 8.2 半开区间运算符\n 8.3 单侧区间\n 9 逻辑运算符\n 9.1 逻辑非运算符\n 9.2 逻辑与运算符\n 9.3 逻辑或运算符\n 9.4 混合逻辑运算\n 9.5 显式括号\n **/\n/*\n 专门用语\n 运算符包括一元、二元、三元：\n\n 一元运算符对一个目标进行操作（比如 -a  ）。一元前缀运算符在目标之前直接添加（比如 !b ），同时一元后缀运算符直接在目标末尾添加（比如 c! ）。\n 二元运算符对两个目标进行操作（比如 2 + 3  ）同时因为它们出现在两个目标之间，所以是中缀。\n 三元运算符操作三个目标。如同 C，Swift语言也仅有一个三元运算符，三元条件运算符（  a ? b : c ）。\n 受到运算符影响的值叫做操作数。在表达式 1 + 2  中， +  符号是一个二元运算符，其中的两个值 1 和 2 就是操作数。\n **/\n//没有i++,i--.有区间运算符来代替\nvar a = (1*2)+3\nvar b = 1+2+3\n//运算符的一个优先级\nprint(b)\nprint(a)\n//可选类型与运算符（可选运算符（三元运算符的一个简写方式））\nvar a1:Int? = 100\nvar value1 = a1\nvar value = a1 ?? 0\nprint(value,value1)\nvar value3 = a1 != nil ? a1! : 0//var value = a1 ?? 0的三元运算符的表达方式，\n//如果a1不等于空则返回？左边的的东西，否则返回？右边的东西\nprint(value3)\n//var value = a1 ?? 0的if语句判断表达方式\nvar value4 = -1\n\nif (a1 == nil) {\n    value4  = 0\n}else{\n    value4 = a1!\n}\nprint(value4)\n\n
	第六节课
		1-if语句；2-可选类型绑定；3-隐式展开；  
			import Cocoa\n\nvar str = "Hello, playground"\n//1 - if语句\nvar a = 10\nif (a<10) {\n    print("a小于10")\n}else if(a > 10){\n    print("a大于10")\n}else{\n    print("a等于10")\n}\n  //元祖类型在if语句中的运用\nvar a1 = ("hello",true)\nvar b = ("hello",true)\nif (a1 == b) {\n    print("a == b")\n}\nelse{\n    print("a != b")\n}\n\n//2 - 可选项绑定（可选类型在if语句中的应用）\n//可能就是用于根据用户输入的结果来反馈不同的操作，例如输密码界面，当用户未输入任何密码时，就执行nil的一个对应操作\nvar a2:Int? = 10\n//print(a2)\nif let value = a2\n{\n    print("value的值 = \(value)")\n}else{\n    print("没有值")\n}\n\nvar b1:String? = nil\nif var value12 = b1 {//注意这里的可选类型b1没有加叹号解析值（强行解析）\n    print(value12)\n//    如果b1有值那就打印value12\n}else{\n    print("null")\n}\n\n//3 - 隐式展开\nvar a0:Int! = 100//当确定a0是一个不变值是可以直接使用叹号！||所以我认为一般来说直接定义为let常量即可\n//问：如果a0已经确定有值了，那么直接var a0:Int = 100与加叹号！var a0:Int! = 100的区别是什么？\n//答：var a0:Int = 100后，不能再将a0 = nil（即普通情况下不能让它没有值），而后者则可以再次让a0 = nil（特殊情况下可以让有值得a0变为没有值）\n//隐式展开主要用在有值的情况下，如果是nil，则会报错\nvar b0:Int = a0\nprint(b0)\n\n\n
	第七节课
		1 -switch case；2 -fallthrough穿透效果
			import Cocoa\n//1 -switch case（默认没有一个穿透的效果，你匹配到那里就到哪里）\nvar a = 10\nswitch a {\ncase 10:\n    print("情况一")\n    fallthrough\ncase 20:\n    print("--2")\ndefault:\n    print("--0")\n}\n\n//2 -fallthrough穿透效果\n//eg1:匹配string类型\nvar a1 = "f"\nswitch a1 {\ncase "a","b","c"://多个值同时匹配，只要有一个相同就可以执行\n    print("--情况一")\n    \ncase "e","f":\n    print("--2")\ndefault:\n    print("--0")\n}\n//eg2：匹配元祖类型\nvar a2 = ("hello",100)\nswitch a2 {\ncase ("hello",100):\n    print("--情况一1212")\n    \ncase ("hello",200):\n    print("--2")\ndefault:\n    print("--0 null")\n    \n//    eg2-1\n    var value = (10,20)\n    \n    switch value{\n    case let(name1,name2):\n        print("name1 = \(name1)")\n        print("name2 = \(name2)")\n        \n    case var(10,name3):\n        \n        print("name3 = \(name3)")\n    default:\n        \n        print( "else else esle" )\n}\n//    eg2-2\n    var value1 = (10,20)\n    \n    switch value1{\n    case let(30,40):\n     print("---01")\n    case var(10,name3):       //（元祖的一个拆分匹配）此时10与10匹配，20与哪么赋值\n        \n        print("name3 = \(name3)")\n    default:\n        \n        print( "else else esle" )\n}\n//    eg2-3 where条件匹配\n    var value3 = (10,20)\n    \n    switch value3{\n    case let(name1,name2) where name1>name2:\n        print("name1 = \(name1)")\n        print("name2 = \(name2)")\n        \n    case var(10,name3):\n        \n        print("name3 = \(name3)")\n    default:\n        \n        print( "else else esle" )\n}\n//eg3:整形   （包含区间运算符）\nvar a3 = 3\nswitch a3 {\ncase 1..<5://表示1 - 4\n    print("--1")\n    \ncase 5...10://（ 表示5- 10，包含10）\n    print("--2")\ndefault:\n    print("--0 null")\n}\n}\n
	第八节课
		1 -区间运算符；2 -for in循环；3 -continue和break
			import Cocoa\n//1 -区间运算符（表示一定的范围）\nvar a = 1...4\nprint("范围= \(a)")\nvar b = 1..<4\nprint("范围= \(b)")\nvar c = -3...4\nprint("范围= \(c)")\nvar d = (-2.5)...4.4\nprint("范围= \(d)")\nvar e = 1...\nprint(e)//无限循环\n//2 -for in 循环\nfor index in 0...5{//代替i++,i--(类似Java当中的增强for循环)\n[for(demo d:a){\nd.sout\n        }\n]\n    print(index)\n}\n//2-1               包括开头   不包括结尾   跳值间隔为2\nfor index1 in stride(from: 0, to: 10, by: 2) {\n    print(index1)\n}\n//2-2               包括开头   包括结尾   跳值间隔为2\nfor index2 in stride(from: 0, through: 10, by: 2) {\n    print(index2)\n}\n//2-3 （反向）      包括开头   包括结尾   跳值间隔为2   翻转打印\nfor index3 in stride(from: -4, through: 10, by: 2).reversed() {//赋值就可以从后往前去前取值\n    print(index3)\n}\n//3 -continue和 break\nfor index01 in (0...2) {\n    print("外部循环 = \(index01)")\n    for item in (0...2) {\n        if (index01 == 1) {\n          break\n        }\n        print("内部循环item = \(item)")\n    }\n    print(index01)\n}\n
	第九节课
		1 -while循环；2 -repeat whlie循环（do whlie循环）
			import Cocoa\n//1 -whlie循环\nvar a = 0\nvar b = true\nwhile (b/*逻辑判断*/) {\n    print(a)\n    a += 1\n    if (a>5) {\n        b = false\n    }\n}\n//2 -repeat whlie循环（do whlie）\nvar a1 = 0\nvar b1 = true\nrepeat{\n    print(a1)\n    a += 1\n    if (a>5) {\n        b = false\n    }\n}\n//先运行一遍repeat，再进行whlie逻辑判断\nwhile ( b1 /*逻辑判断*/)\n
	第十节课
		1 -String基本操作
			import Cocoa\n\n//第10课  1 -string基本操作\nvar str = "ABCDEF"\nprint(str.count)//打印字符串长度\nstr.startIndex\nstr.endIndex\nprint(str[str.startIndex])//可以拿开头的位置\n//print(str[str.endIndex]) 不能拿结尾的位置 （并不是指的F的位置，而是F的后一位）||（为空）\nprint(str[str.index(before: str.endIndex)])//想要拿F则应该拿end的before位置\nprint(str[str.index(str.startIndex,offsetBy: 3)])//从str.startIndex位置开始从0开始数（偏移量）offsetBy: 3位拿出\n//区间语法\nvar a = str.index(str.startIndex,offsetBy: 2)\nvar b = str.index(str.startIndex,offsetBy: 4)\nprint(str[a...b])\n\nvar c = str.firstIndex(of: "E") ?? str.endIndex//从str.firstIndex位置开始取到(of: "E")连续取值，如果无值就取？？后面的东西\nprint(str[str.startIndex...c])\nprint(str.prefix(4))//从第一个开始数四位\n//从后往前拿值\nlet index2 = str.index(str.endIndex,offsetBy: -2)//从结尾的位置开始算，往前拿两个\nprint("ABCDEF中，后2位的字符串 = " + String(str[index2..<str.endIndex]))\nprint(str[str.index(after: str.startIndex)])//开始位置的后一位\n//增删改查\n//判断字符串里是否有某个字符/字符串\nprint(str.contains("C"))\nprint(str.contains("CDE"))//判断某部分字符串是否在字符串里，都有才则true（一假则假，且语法）\nprint(str.contains(where: String.contains("BK")))//判断某部分字符串是否在字符串里，有则true（一真则真，或语法）\nprint(str.contains(where: String.contains("KK")))\n//判断前缀后缀\nprint("判断ABCDEF是否包含某个字符串前缀 = " + String(str.hasPrefix("AB")))\nprint("判断ABCDEF是否包含某个字符串后缀 = " + String(str.hasSuffix("EF")))\n//追加字符串\n//str.append("abcdefgggg")\n//print(str)\n//插入字符串\n//str.insert(contentsOf: "hello", at: str.index(str.startIndex, offsetBy: 3))\n//插入contentsOf: "hello"，在从str.startIndex开始数offsetBy: 3个的位置\nprint(str)\n//修改（替换）(用的还是索引方法)\nlet index1 = str.index(str.startIndex,offsetBy: 1)//B\nlet index3 = str.index(str.startIndex,offsetBy: 3)//D\nlet range = index1...index3//B.C.D(不含D)\n//str.replaceSubrange(range, with: "123456")\nprint(str)\n\n//将某一个字符替换成某一个字符，替换完成后返回一个新的字符串\n//var new_value = str.replacingOccurrences(of: "BC", with: "888")\n//print(new_value)\n//str.remove(at:str.index(str.startIndex,offsetBy: 2))//删除C\n//print(str)\n//\n//var a1 = str.index(str.startIndex,offsetBy: 1)//B\n//var b1 = str.index(str.startIndex,offsetBy: 3)//D\n//str.removeSubrange(a...b)//删除BCD\n//print(str)\n\n\n//遍历字符串  方法一：直接遍历；方法二：索引遍历\n//方法一：直接遍历；\nfor item in str {\n    print(item)\n}\n//方法二：索引遍历\nfor item1 in 0..<str.count {\n    print(str[str.index(str.startIndex, offsetBy: item1)])\n}\n\n//多行文本  (三个引号) (按照你的格式输出)\nvar dd = """\n efgeyfgefgf34yufg34yfg34yfg34gyf\n得我翁ewf21\nfwew而非   的王国风云\n"""\nprint(dd)\n//想输出带引号（转意）  #"    内容    "#\nvar aa = #" "hello"   code "#\nprint(aa)\n\n\n
	第十一课
		Array数组
			import Cocoa\n//1 -Array数组\n// 数组的定义方法\n//直接定义\nvar a = [1,2,3,4]\nprint(a)\n//指定数组类型\nvar b:[String] = ["apple","ios"]\nprint(b)\n//通过数组类型进行定义(结构体)\nvar c:Array<Double> = [1.5,1.6]\nprint(c)\n//取数组中的某个值\nprint(c[0])\nprint(b[1])\n//修改值\nc[0]  = 8.8\nprint(c[0])\n//定义一个空的数组\nvar array:Array<Int> = []\nprint(array)\n     //通过初始化器定义一个空数组\nvar arra1 = [Int]()//通过初始化器（类似一个构造方法），定义可变的空数组\n//在尾部添加新变量\narra1.append(1)\narra1.append(2)\narra1.append(3)\nprint(arra1)\n//通过初始化器定义一个空数组，构造体\nvar arra3 = Array(repeating: -1, count: 3)\nprint(arra3)\narra3[0] = 100\nprint(arra3)\n\n//用let定义的常量，不可变数组，不能改变长度和数量，但可以取值\n\n//对数组的基础操作  增删改查\n//定义数组\nvar array01 = ["ios","watchos","macos"]\n//增   用加号拼接一个数组\narray01 += ["hello","world"]\nprint(array01)\n//增    追加的方式 在数组末尾增加一个新的字符串\narray01.append("asdfghjkl")\nprint(array01)\n//修改\narray01[1] = "iiooss"\nprint(array01)\n//插入  在某一个位置插入某一个值\narray01.insert("aaaa", at: 1)\nprint(array01)\n//查找\nprint(array01.contains("macos"))\n//         替换\narray01.replaceSubrange(0..<1, with: ["111","222"])\nprint(array01)\n//删除\narray01.remove(at: 0)\nprint(array01)\n\n//数组的排序演示\nvar array02 = ["A","C","D","B","F","E"]\n//倒序sort\n//这里需要一个闭包，一个匿名函数\n//传一个函数，函数也可以作为值传递\n/*\n 类似于Java 的Lambda 表达式\n lambda 表达式的语法格式如下：\n\n (parameters) -> expression\n 或\n (parameters) ->{ statements; }\n **/\narray02.sort(by: {(s1,s2) -> Bool in\n    if s1>s2 {\n        return true\n    }else\n    {\n        return false\n        \n    }\n})\nprint(array02)\n\n//数组比较\nvar array11 = [1,2,3]\nvar array22 = [1,2,3]\nif (array11 == array22) {\n    print("array11和array22相等")\n}else{\n    print("array11和array22不等")\n}\n\n\n//数组遍历\nvar array33 = ["A","C","D","B","F","E"]\n//类似Java当中的增强for循环\nfor item in array33[1...2] {\n    print(item)\n}\n//返回数组长度\n//数组索引遍历\nfor index in 0...array33.count {\n    print(index)\n}\n//反向打印\nfor index in (0...array33.count).reversed() {\n    print(index)\n}\n//无限大，表示从索引0开始把数组的所有值去出来\nfor index in array33[0...] {\n    print(index)\n}\n\n
	第十二课
		1 -Set集合
			import Cocoa\n//1 -Set集合\nvar a:Set = [1,2,3,4]\nprint(a)\n//指定Set集合的类型\nvar b:Set<String> = ["hello","world"]\nprint(b)\n//集合可以为空\nvar c:Set<Int> = []\nprint(c)\n//Set集合的常规操作  增删改查\n\nvar set_List:Set = ["hello","world","ios"]\nprint(set_List.count)\n//增加\nset_List.insert("aaa")\nprint(set_List)\n//是否包含这个数组\nprint(set_List.contains("asdfghjkl"))\n//删除\nset_List.remove("hello")\nprint(set_List)\n//\nvar set_List1:Set = ["hello","world","swift"]\nlet data:Set = ["iphone","android","ios","swift"]\nvar new_set1 = set_List.union(data)//将两个Set合并，返回新的Set\nprint(new_set1)//如果合并的两个数组有相同的部分，就变成一个，且返回新数组每次打印的顺序还不一样，是随机的\n//.union()  即并集\n//\nvar new_set2 = set_List1.intersection(data)//返回两个Set中相同的数据\nprint(new_set2)\n//\nvar new_set3 = set_List1.symmetricDifference(data)\n//返回两个数组中不同的数据\nprint(new_set3)\n//\nvar new_set4 = set_List1.subtracting(data)\n//比较两个Set，返回前面Set中与后面Set中不同的数据\nprint(new_set4)\n\n\n//两个Set集合相等判断\nvar a1:Set = ["A","B"]\nvar b1:Set = ["B","A"]\nif (a1 == b1) {\n    print("两个集合相等")\n}\nelse{\n    print("两个集合不等")\n}\n//结果：两个集合相等（只要数据个数相同，不在乎顺序）   因为Set集合是无序的\n//过滤Set集合(匿名函数，搞一个闭包)\nvar set_list3:Set = ["A","B","C","D"]\n//                             (匿名函数，搞一个闭包)\nvar new_value =  set_list3.filter({(item) -> Bool in\n    if (item == "B" || item == "C"){\n        return false//表示不需要“B”和“C”\n    }else{\n        return true//其他的都是true就返回，所以BC就被过滤掉了\n    }\n})\nprint(new_value)\n//遍历Set集合  （因为Set集合是无序的，循环一下就行了）\nvar set_list4:Set = ["A","B","C","D"]\n/*\n 因为Set集合是无序的\n set_list4[0]就是一个错误的写法\n **/\n//直接遍历\nfor ietm in set_list4 {\n    print(ietm)\n}\n\n\n\n\n\n\n\n\n
	第十三课
		Dictionary集合
			import Cocoa\n//Dictionary集合  字典\n//类似于其他语言中的map集合，通过key获得value的一个值\n//   1 -初始化定义方式\nvar a:Dictionary<String,String> = ["a":"A","b":"B","c":"C"]\nprint(a)//第一种比较清晰\nvar b:[Int:String] = [1:"A",2:"B"]\nprint(b)\nvar c = [1:"hello"]\nprint(c)\n\n//基本操作\nvar dic = ["a":"A","b":"B","c":"C"]\nprint(dic["a"])\n//Optional("A")结果是一个可选类型，它不知道你有没有值，它甚至不知道你有没有这个key\n//解决处理可选类型的方法一： 合并空值运算符？？\nprint(dic["a"] ?? "unknow")\n//修改值\ndic["a"] = "000" //将key为a的对应的value改变为“000”\nprint(dic)\n//修改键值对\ndic.updateValue("swift", forKey: "ios")\nprint(dic)//有key为“ios”就更该，无key“ios”就添加一个新的到最后\n//删除\ndic.removeValue(forKey: "a")\nprint(dic)\n//可选项的绑定 (与合并可选项空值运算符差不多)\nvar dic1 = ["a":"A","b":"B","c":"C"]\nif let value = dic["a"] {\n    print(value)\n//    如果dic["a"]有值就赋给\n//    valuie相同没关系，只要key不同就行\n}\n\n//过滤字典\nvar new_value = dic.filter({(key,value) -> Bool in\n    if (key == "b"){\n        return false\n    }\n    return true\n})\nprint(new_value)\n//遍历循环 不需要向其他语言那么复杂，swift用一个元祖就搞了\nvar dic11 = ["a":"A","b":"B","c":"C"]\nfor (a,b) in dic11 {\n    print("Key = " + a + "  " + "Value = " + b)\n}\n\n
	第十四课
		1 -函数定义：2 -函数参数名称问题；3 assert断言
			import Cocoa\n//1 函数定义(方法)\nfunc test(/*参数列表*/)\n{/*方法体\函数体**/\n    print("test()")\n}\ntest()\n\nfunc test2() -> Int//Void//void表示没有返回值，可以不用写\n{\n    return 100\n}\nprint(test2())\n\nfunc test3(name:String) -> String\n{\n    return name\n}\nprint(test3(name: "hello"))\n\nfunc test4(name:String...)//表示可变参数\n{\n    print(type(of: name))\n}\ntest4(name: "a","b")\n\nfunc test5(name:(n1:String,n2:Int)) -> (String,Int)//元祖\n{\n    var value:(a:String,b:Int)\n//    元祖在这里初始化\n    value.a = name.n1 + " ios"\n    value.b = name.n2  + 10\n    return value\n}\nvar value:(c:String,d:Int) = test5(name:(n1:"hello",n2:20))\nprint(value.c)//通过名称拿值\n//print(value.c.n1)\nprint(value.d)\nprint(value)\n\n//2 函数参数名称问题\n/*\n 当函数外部调用时用outname，当函数里使用时调用inname,不能颠倒不能互换\n //(函数实际标签         形式参数名)||（外部调用名字，内部使用名）||（形参，实参）\n **/\nfunc test01(outname inname:String)\n{\n    print(inname)\n}\ntest01(outname: "helol")\n\nfunc test02(name:String)\n//只写一个的时候是一个外部名称，而内部名称默认和外部名称一样\n{\n    print(name)\n}\ntest02(name: "world")\n\nfunc test22(_ inname:String)\n{\n    print(inname)\n}\n//_:表示外部名称被忽略了，在外部调用时直接传值就行，不用在说明outname还是inname\n//但是innane不能够被忽略，因为outname不能用在内部，这样就没法取值了\ntest22("没有说明外部名称outname了，因为已经在函数中用下划线忽略了")\n\nfunc test33(outn1 inn1:String,outn2 inn2:Int)\n{\n    print(inn1,inn2)\n}\ntest33(outn1: "AAAAAA", outn2: 1000)\n\n//assert断言\n//assert函数可以让程序停止运行\nfunc play(param:Int)\n{\n    if (param<10) {\n        assert(false,"停止⏹运行🏷🙅🏻‍♀️")\n    }\n    print("值 = " + String(param))\n}\n\nplay(param: 20)\nplay(param: 5)\n/*打印结果\n Assertion failed: 停止⏹运行🏷🙅🏻‍♀️: file __lldb_expr_1/第14p.playground, line 78*/\n\n
	第十五课
		1 ——guard拦截语句：2 ——guard语言和if语句，在处理可选项绑定之间的区别比较
			import Cocoa\n// 1 ——guard拦截语句;\n//2 ——guard语言和if语句，在处理可选项绑定之间的区别比较\n//定义：拦截语句\nfunc test1(param:Int) -> Int\n{\n    guard param<10\n    else {\n        print("进入guard语句里")\n        return 100\n        //一旦return后，后面的语句就不会执行了\n    }\n    return 1\n}\n\nprint(test1(param: 5))\nprint(test1(param: 115))\n\nfunc test2(param:Int)\n{\n    if (param<=10) {\n        print("进入if语句里")\n        print("hello world")\n    }else{\n        print("进入if else语句里")\n        return\n    }\n    print("asdfghjkl")\n}\nprint(test2(param: 15))\n\n// 可选项绑定的问题（gurad语句和if语句的比较）\n//guard就是理解成保护就可以了，简化条件判断的写法\nvar a:String? = "swift"\nfunc test11(param:String?)\n{\n    guard let value = param else {\n        print("进入guard语句里面")\n        return\n    }\n    print("值 = " + value)\n    /*\n     问题：为什么函数内部的value可以直接在这里调用\n     答案：因为如果调用函数是的可变参数符合规定，就不会进入gurad语句，就不会被拦截，可以被执行\n     并且if语句就不能在外面调用\n     */\n}\ntest11(param: a)\nvar b:String? = nil//对空值的判断\ntest11(param: b)\n//用if语句同样可行\n\nfunc test22(param:String?)\n{\n    if let value = param {\n        print("进入if里面")\n        print(value)\n    }\n    else{\n        print("进入else里面")\n        return\n    }\n}\nprint("__________________")\ntest11(param: b)\ntest22(param: a)\n//guead主要是用来解决if嵌套的，如果一个函数有多个if嵌套会不好\n\n
	第十六课
		1 -inout关键字：2 -函数类型；3 -函数类型的变量或常量赋值
			子主import Cocoa\n//1 -inout关键字（解引用）\nfunc test(param: inout Int)\n{\n    param *= 2\n    print(param)\n}\nvar a = 10\nprint("传递前a = " + String(a))\ntest(param: &a)\nprint("传递后a = " + String(a))//这样a的值也就会被改变\n//    未加inout关键字之前会报错，因为成员变量不能直接用在方法体中就行操作\n//    即：值传递变成引用传递（传递地址了）\n\n\n//2 -函数类型(函数类型是由 参数 和 返回值 组成)\n//3 -函数类型的变量或常量赋值\n//定义\nfunc test1  (para:Int)\n{\n    print(para)\n}\nvar a1:() -> Void\n//a是一个函数类型(没有参数，没有返回值)\nvar b1:(Int,String) -> String\n//b是一个函数类型（有两个不同类型的参数，返回一个string类型的参数）\nlet c1:([Int]) ->(Int,String)\n//c是一个由数组作为参数，元祖作为返回值函数类型\n\n//函数类型的使用\nfunc testA() -> Void\n{\n    print("testA")\n}\nvar a2:() -> Void = testA\na2()//把testA赋给a2，就相当于调用testA\n \n//用匿名函数来写\n//如果不想在外面定义一个函数，就可以用比较方便的匿名函数\n//大括号{}里面写匿名函数的方法体\n//in 后面写方法体（实现方式）\nvar b2:() -> Void = {() -> Void in\n    print("匿名函数")\n}\nb2()\nprint("---------------------------")\nfunc testB(param1:String,param2:Int) -> String\n{\n    return param1 + String(param2)\n}\nvar c2:(String,Int) -> String = testB\nprint(c2("hello",10))//就相当于是在调用testB\nprint("---------------------------")\n//用匿名函数来写\n\nvar d2:(String,Int) -> String = {(param1:String,param2:Int) -> String in\n    return param1 + String(param2)\n}\n\nprint(d2("swift0",20))\nprint("---------------------------")\nfunc testC(param:[Int]) -> String\n{\n    var temp:String = ""\n    for item in param {\n        temp += String(item)\n    }\n    return temp\n}\nvar e2:([Int]) -> String = testC\n\nvar value = e2([1,2,3])\nprint(value)\n//e2()匿名函数的写法\nvar f2:([Int]) -> String = {(array:[Int]) -> String in\n    var temp:String = " - "\n    for item in array {\n        temp += String(item)\n    }\n    return temp\n}\nprint(f2([4,5,6]))\nprint("---------------------------")\nvar g2:([Int]) -> String = f2\n//甚至可以直接把一个被赋了函数的变量直接再赋个另外一个变量或常量（本质还是调用的函数）\nprint(g2([41,51,61]))\n\n\n题1
	第十七课
		函数类型作为函数的参数类型
			import Cocoa\n\n//第16p的延续\n//函数类型作为函数的参数类型\nfunc test(){\n    print("test()函数，并没有参数，没有返回值")\n}\nvar a:() -> Void = test\na( ) //a是函数类型的变量，所以所以a变量，就相当于使用函数test()\nfunc test1(param:() -> Void) { //函数test1的参数param是一个不带参数，没有返回值的函数类型\n    param()\n}\ntest1 (param: test)//将函数test()赋值给函数test1（）的类型为函数的参数param，然后参数param直接调用test()\nprint("-- - - - - - - - - -  - - -- -  - - -")\n//eg2:匿名函数方式\ntest1(param: {() -> Void in print("匿名函数，没有参数，没有返回值")\n    \n})\nprint("-- - - - - - - - - -  - - -- -  - - -")\n//eg3:\nfunc sum(param:(Int,Int) -> Int) -> Int\n//函数sum的参数是一个(Int,Int) -> Int的函数类型，然后函数sum还要自己返回一个int类型\n{\n    let value = param(1,2)\n    print("value = \(value)")\n    return value\n}\nfunc add(a:Int,b:Int) -> Int\n{\n    return a+b\n}\nprint(sum(param: add))\nprint("-- - - - - - - - - -  - - -- -  - - -")\n//eg3-1:用匿名函数来写\n\nvar value =  sum(param: {(a:Int,b:Int) -> Int in return a+b})\nprint("值 = \(value)")\n\n//eg4 使用匿名函数\nvar array = [1,5,6,8,7]//大小排序\narray.sort(by: {(a,b) -> Bool in\n    if (a<b) {\n        return true\n    }\n    return false\n}) //throws是指抛出异常\nprint(array)\n//eg4-1 不使用匿名函数\nfunc play2(a:Int,b:Int) -> Bool\n{\n    if (a<b) {\n        return true\n    }\n    return false\n}\narray.sort(by: play2)\nprint(array)\n
	第十八课
		1 -函数类型作为返回值；2 -内嵌函数
			import Cocoa\n//1 -函数类型作为返回值\n//函数test参数parma是一个返回int类型的函数类型，同时函数test本身也返回一个int类型\nfunc play1(value:Int) -> Int\n{\n    return value * value\n}\nfunc play2(value:Int) -> Int\n{\n    return value + value\n}\n\nfunc test(param:Bool) -> (Int) -> Int\n{\n    return param ?play1:play2//三元运算符\n}\nvar a = test(param: true)\nprint(type(of: a))\n\nprint(a(3))\n\nprint("- -- - -  --  -- - - - - -  -- - - -")\n//2 -内嵌函数(在函数里面定义函数，可以作为值进行返回)\n//eg2:\nfunc test1(param:Bool) -> (Int) -> Int\n{\n    func play1(value:Int) -> Int\n    {\n        return value * value\n    }\n    func play2(value:Int) -> Int\n    {\n        return value + value\n    }\n    return param ?play1:play2//三元运算符\n}\nvar b = test1(param: false)\nprint(b(3))\n
	第十九课
		匿名函数的几种简写方式
			import Cocoa\n//匿名函数的几种简写方式\n//一般不提倡简写\n//为了能够看懂\nvar a:() -> Void = {() -> Void in print("aaa")}//匿名函数写法\nprint(type(of: a))\n//简写11111111\nvar b:() -> Void =\n    {\n    /*() -> Void in*/\n        //如果没有返回值就不用写\n    print("bbb")\n}\ntype(of: b)\n//简写2：直接根据类型推断，连变量的函数类型都不需要写\nvar c = {}\nprint(type(of: c))\nprint(" - - - -- - -- - - - -  - -  - - --  ")\n//简写3333333333\nfunc test(param:() -> Void)\n{\n    param()\n}\ntest(param: {() -> Void in print("asdfghjkl")})\ntest(param: {              print("asdfghjkl")})\n//简写44444444444\nprint(" - - - -- - -- - - - -  - -  - - --  ")\ntest{print("qwertyuiop")}//不清晰\n//这个函数没有参数，没有返回值，干脆连括号都不用写了\n//简写55555555555\nprint(" - - - -- - -- - - - -  - -  - - --  ")\nfunc test2(param:(Int) -> Void)\n{\n    param(10)\n}\nprint(test2(param: {(value:Int) -> Void in print("volue")}))\n//简写555（） 如果只有一个参数，干脆连括号都不用写了\n//简写666\nprint(" - - - -- - -- - - - -  - -  - - --  ")\nprint(" - - - -- - -- - - - -  - -  - - --  ")\nprint(" - - - -- - -- - - - -  - -  - - --  ")\nfunc test3(pa:(Int,Int) -> Int)\n{\n    print(pa(20,30))\n}\ntest3(pa: {(it1:Int,it2:Int) -> Int in return it1+it2})\ntest3(pa: {                                   $0 + $1})\n// 内置语法：$美元符号(类似于参数的索引方式)\n
	第二十课
		//1 -定义枚举\n//2 -数组枚举初始值
			import Cocoa\n//1 -定义枚举\n//结构体，类....（驼峰命名法）\n//方法，属性...（后大写）\nenum TestEnum\n{\n    case A\n    case B\n    case C\n}\nfunc paly(pa:TestEnum) -> Void {\n    if (pa == TestEnum.A) {\n        print("AAAAAA")\n    }else     if (pa == TestEnum.B) {\n        print("BBBBBB")\n    }else if (pa == TestEnum.C) {\n        print("CCCCCC")\n    }\n}\npaly(pa: TestEnum.B)\nprint(TestEnum.A)\n//2 -数组枚举初始值\nenum TestEnum01:Int//给枚举赋值，要先申明赋值的类型\n{\n    case A = 1\n    case B = 2\n}\nprint(TestEnum01.A)//A\nprint(TestEnum01.A.rawValue)//原始值 1\n
	第二十一节课
		1.枚举相关值；2.遍历枚举
			import Cocoa\n//1 -设置枚举相关值\nenum TestEnum\n{\n    case naem(String)\n    case age(Int)\n    case xy(Int,Int)\n}\nfunc pla(param:TestEnum) -> Void {\n    switch param {\n    case TestEnum.naem("hello"):\n        print("hello")\n    case TestEnum.age(10):\n        print(10)\n    case TestEnum.xy(100, 200):\n        print(100,200)\n    default:\n        print("没有匹配")\n    }\n}\npla(param: TestEnum.naem("swift"))\npla(param: TestEnum.age(10))\npla(param: TestEnum.xy(10, 200))\n//2 -遍历枚举\nenum TestEnum1:CaseIterable//一个case值的迭代器\n{\n    case A\n    case B\n    case C\n}\n//拥有allCaeses属性->是一个数组\n\nprint(type(of: TestEnum1.allCases))\nfor item in TestEnum1.allCases\n{\n    print(item)\n}\nprint(" -- - - - -- - -  ---  - - - - - -- -")\nfor item in (0..<TestEnum1.allCases.count)\n{\n    print(item)\n    print(TestEnum1.allCases[item])\n}\n
	第二十二节课
		结构体的定义和使用
			import Cocoa\n//结构体定义使用\n//1 -结构体\n//2 -mutating关键字\n\nstruct Student//结构体\n{\n    var name = "unknown"\n    var age = 0\n    var score = 0.0\n    var ispass = false\n    \n    static let schoolName = "家里蹲大学"\n    //静态属性，可以直接用结构体的名称调用\n    \n    //初始化init()\n    //空初始化器：\n    init() {\n        \n    }\n    //非 空初始化器：\n    init(name:String,age:Int,score:Double)\n    {\n        self.name = name\n        self.age = age\n        self.score = score\n        \n        if (self.score < 60)\n        {\n            self.ispass = false\n        }\n        else\n        {\n            self.ispass = true\n        }\n    }\n    \n    func getName() -> String{\n        return self.name\n    }\n    \n    func getScore() -> Double\n    {\n        return self.score\n    }\n    \n    func getIsPass() -> Bool\n    {\n        return self.ispass\n    }\n    \n//若要修改结构体中已经定义的值，需要加mutating关键字，否则会报错：\n//Cannot assign to property: 'self' is immutable\n    mutating func setScore(score:Double)\n    {\n        self.score = score  //要设置成新函数传进来的分数，否则就错了\n        \n        if(self.score < 60)\n        {\n            self.ispass = false\n        }\n        else\n        {\n            self.ispass = true\n        }\n    }\n    \n}\n \n//通常 不建议在结构体中 加定义函数，为了和类区别开\n//下面进行实例化：\nvar a = Student()\nprint(a.getName())\n//结果是unknown因为没有在实例化a的时候传值，因此用了第一个空的初始化器\n//下面进行传值处理\nvar b = Student(name: "小明", age: 18, score: 90)  //b是Student类型，直接通过类型推断，不用标注\nprint(Student.schoolName,"学校的",\n      /*这里的静态常量schoolName只能用结构体Student来进行调用，否则报错*/\n    b.getName(),"同学的分数是：",b.getScore(),"他是否通过了考试：",b.getIsPass())\n//或者直接调用变量，不调用函数\nprint(Student.schoolName,"学校的", /*这里的静态常量schoolName只能用结构体Student来进行调用，否则报错*/\n    b.name,"同学的分数是：",b.score,"他是否通过了考试：",b.ispass)\n//调用setScore()进行修改\nvar c = Student(name: "小王", age: 18, score: 90)  //b是Student类型，直接通过类型推断，不用标注\n//小王同学的分数有问题，进行分数修改\nc.setScore(score: 50)\n \nprint(Student.schoolName,"学校的", /*这里的静态常量schoolName只能用结构体Student来进行调用，否则报错*/\n    c.name,"同学的分数是：",c.score,"他是否通过了考试：",c.ispass)\n \n/*\nunknown\n家里蹲大学 学校的 小明 同学的分数是： 90.0 他是否通过了考试： true\n家里蹲大学 学校的 小明 同学的分数是： 90.0 他是否通过了考试： true\n家里蹲大学 学校的 小王 同学的分数是： 50.0 他是否通过了考试： false\n*/\n//3.结构体实例也是值传递\n\nstruct Test\n{\n    var age = 10\n}\n \nvar t1 = Test()\nprint("t1.age = ",t1.age)\nvar t2 = t1\nprint("t2.age = ",t2.age)\n \nt2.age = 100  //改变t2.age的值，看看t1.age的值有没有改变\nprint("t1.age = ",t1.age)\nprint("t2.age = ",t2.age)\n//发现t1.age=10,t2.age=100,说明结构体传递是传递值，不是传引用\n/*\nt1.age =  10\nt2.age =  10\nt1.age =  10\nt2.age =  100\n*/\n//4.常量和变量实例\n\n//常量变量问题\nstruct Test1\n{\n    var a = 1123\n    let b = 100\n}\n\nvar t11 = Test1()\nprint(t11.a,t11.b)\n\nt11.a = 10\n//t.b = 10  //Cannot assign to property: 'b' is a 'let' constant\n//不能改变t11.b的值，因为b属性是let常量\nprint(t11.a,t11.b)\nprint("----------------------")\n//同样的，假如在定义实例的时候就将之定义为let，那即使属性a是var也不能修改值\nlet t22 = Test()\n\n
	第二十三节课
		1 -计算属性set 和 get；2 -只读属性；
			import Cocoa\n//1 -计算属性set 和 get；\nstruct Person\n{\n    private var value = "  "\n    //操作符重载 （拦截重写两个方法）（属性拦截）\n    var name:String//是一个结构体类型，相当于重新改写了set和get方法\n    {\n        set\n        /*parma*/\n        //这个param可以不用写\n        {\n            value = /*parma*/newValue + "  -  hello world -  "\n            print("set - " + /*parma*/newValue)\n            //newValue是set方法默认的param写法\n        }\n        get\n        {\n            print("get")\n            return value\n        }\n    }\n    init()\n    {\n        \n    }\n}\nvar person = Person()\nperson.name = "swift"//修改属性的时候执行的是set方法\n//类似函数，但是它是一种内置的方式\nperson.name\n\n\n//2 -只读属性；就是直接不写set方法，只写get方法（拦截默认方法）\nstruct Person1\n{\n    private var value1 = "hello world"\n    var  name1:String\n    {\n        get\n        {\n            return value1\n        }\n    }\ninit()\n{\n    \n}\n}\nvar person1 = Person1()\n//person1.name1 = "-swift-"\nprint(person1.name1)\n//eg3:初始化是给它设置值\nstruct Person12\n{\n    private var value12 = "hello world"\n   /*private 控制是否内在外部改变其值*/ var  name12:String\n    {\n        set\n        {\n            value12 = newValue\n        }\n        get\n        {\n            return value12\n        }\n    }\n    init(name:String)\n{\n        self.name12 = name12//相当于重新给name12赋值（在内部）\n}   //当private name12时，外部就不能调用并改变name12了，就可以重新定义一个外部函数来解决\n    func getName() -> String {\n        return self.name12//也相当于只读属性\n    }\n}\nvar person12 = Person12(name: "swift--- - - -")\nperson12.name12  = "iooosos"\nprint(person12.name12)//内部\nprint(person12.getName())//外部\n//eg4：\n\nstruct GraphArea\n{\n    private var circleArea:Double = 0//圆的面积\n    private var squareArea:Double = 0//正方形的面积\n    \n    private var original_radius:Double = -1 //储存最新半径 //存储最新半径，开始设置为-1\n    \n    var radius:Double//半径\n    {\n        set(radius)\n        {\n            circleArea = Double.pi * (radius * radius )\n//            π * r平方\n            let diam:Double = radius * 2\n            squareArea = diam * diam   //4pi方\n            \n            original_radius = radius  //半径\n           \n        }\n        get\n        {\n            return original_radius\n        }\n    }\n    \n    init(radius:Double)\n    {\n        self.radius = radius\n    }\n    \n    func getCircleArea() -> Double\n    {\n        return self.circleArea\n    }\n    \n    func getSquareArea() -> Double\n    {\n        return self.squareArea\n    }\n \n}\n \nvar area = GraphArea(radius:10) //在创建GraphArea实例的时传一个半径参数\n//   在init（）初始化构造器里面\nprint("半径 = " + String(area.radius))  //返回area的半径\nprint("圆形面积 = " + String(area.getCircleArea()))\nprint("正方形面积 = " + String(area.getSquareArea()))\n \nprint("-------------------- - -- -  - --------------------------")\narea.radius = 20 //修改半径，每次重设半径值的时候，set代码块都会被执行，也就是所有面积都会被重新计算\nprint("半径 = " + String(area.radius))  //返回area的半径\nprint("圆形面积 = " + String(area.getCircleArea()))\nprint("正方形面积 = " + String(area.getSquareArea()))\n
	第二十四节课
		属性观察（属性监听）
			import Cocoa\n//属性观察（Java中的属性监听）\n//结构体\nstruct Person\n{\n    var address = "  "\n    \n    var name:String = "unkonw"//oc中的KVO\n    {\n        willSet/*（new_value）*/ //操作外部传入的新值\n        {\n            address = newValue\n            print("willSet - " + newValue)//方法默认有一个newValue，不需要自己额外添加变量\n        }\n        didSet(old_value)//操作结构体内部定义的旧值\n        {\n            print("didSet - " + old_value)\n        }\n    }\n//    这里没有init()初始化器(构造方法)，就默认有一个空的\n    init(name:String) {\n        self.name  = name\n    }\n}\n//结构体实例\nvar person = Person(name: "swift")\nperson.name = "hello"//只有更新旧值（即传入新值是才启动监听属性）\nperson.name = "hello"//此时旧值也被更新，即旧值新值都会更新\nprint(person.address)\n/*\n willSet - hello\n didSet - unkonw\n willSet - hello\n didSet - hello\n **/\n
	第二十五节课
		下标语法subscript
			import Cocoa\n//下标语法subscripr\n//结构体\nstruct Person\n{\n    private var array:[String] = ["swift","ios","macos"]\n    subscript(index:Int) -> String\n    //可以通过下标语法做一下额外的功能\n    {\n        set(new_value)\n        {\n            print("set")\n            print(index,new_value)\n        }\n        get\n\n        {\n            print("get")\n            return "apple"\n        }    }\n}\nvar person = Person()//结构体实例\nperson[0] = "hello"\n//person[123456]\nprint(person[123456])\nprint(" - - - - --  - - - - - - - -  - - - - - ")\n//eg2：\nstruct Person1\n{\n    private var array:[String] = ["swift","ios","macos"]\n    subscript(index:Int,parsm:String) -> String\n    //可以通过下标语法做一下额外的功能\n    {\n        set(new_value)\n        {\n            array.insert(new_value + parsm, at: index)\n            \n//               添加某值(甚至可以拼接不同类型变量)，到某一个位置上（数组的）\n        }\n        get\n\n        {\n            return array[index]\n        }    }\n}\nvar person1 = Person1()//结构体实例\n//person1[0] = "hello"\nperson1[0,"A"] = "asdfghjkl"\n//person[123456]\nprint(person[0])\nprint(person[1])\n/*set\n0 hello\nget\napple\n - - - - --  - - - - - - - -  - - - - - \nget\napple\nget\napple*/
	第二十六节课
		//1 -类的定义和使用\n//2 -类的实例传递是传引用
			import Cocoa\n//1 -类的定义和使用\nclass Student\n{\n   \n    private var name:String = "unkonw" //私有变量\n    private var age:Int = -1\n    private var score:Double = -1.0\n    private var ispass:Bool = false\n    \n    public static let schoolName = "成都大学的成都大学"//静态常量\n    init(name:String,age:Int,score:Double)\n    {\n        self.name = name\n        self.age = age\n        isPass(param:score)\n    }\n \n    private func isPass(param:Double)   //私有函数isPass()，传入score参数\n    {\n        self.score = param\n        if self.score < 60\n        {\n            self.ispass = false\n        }\n        else\n        {\n            self.ispass = true\n        }\n    }\n    \n    \n    convenience init()//加convenience关键字的初始化器，无参数\n    //想在一个init里使用另一个init使用此关键字\n\n    {\n        self.init(name: "xiaohong",age: 19, score : 90)\n    }\n    //带参数的初始化器\n   \n \n    \n    //公有函数\n    public func setScore(score:Double)\n    {\n        isPass(param: score) //将isPass()进行封装，不能直接修改isPass,只能通过setScore()来修改score\n    }\n    \n    public func getName() -> String\n    {\n        return self.name\n    }\n    \n    public func getAge() -> Int\n    {\n        return self.age\n    }\n    \n    public func getScore() -> Double\n    {\n        return self.score\n    }\n    \n    //静态函数，直接通过类名调用，不能通过实例调用\n    public static func get() -> String\n    {\n        return "swift"\n    }\n}\n \nvar s1 = Student(name:"ZhangSan",age:20,score:59)\n \nprint("姓名 = " + s1.getName()) //使用结构体属性\nprint("年龄 = " + String(s1.getAge()))\nprint("分数 = " + String(s1.getScore()))\n \nprint(Student.get()) //get()静态函数，直接通过类名调用，不能通过实例调用\n\n//2 -类的实例传递是 传引用(即不是新复制，而是可以将原来的其他东西一起改变)（结构体传的是值）（结构体实际上也是一种值类型（拷贝了一份，拷贝完了两个之间就没关系了））\n//                   在Java中相当于多个引用指向同一个对象  （指针）\nclass Student1\n{\n    var name1 = "hello"\n    let name2 = "world"//类中的常量是不能改变的\n    \n}\nvar  s11 = Student1()//s11现在是变量var\n\nprint(s11.name1)\nvar s22 = s11\nprint()\nprint(s11.name1)\nprint(s22.name1)\ns22.name1 = "ios"\nprint(s11.name1)\nprint(s22.name1)\n\n//定义let常量\nlet s111 = Student1()\ns111.name1 = "swift"\nprint(s111.name1)//类中即使是let常量也可以改变值，而结构体不行，但是类中的常量是不能改变的\n\n\n
				姓名 = ZhangSan\n年龄 = 20\n分数 = 59.0\nswift\nhello\n\nhello\nhello\nios\nios\nswift\n
	第二十七节课
		//在类中使用，属性计算，属性观察，下标语法
			同之前在结构体中讲的差不多
				import Cocoa\n//在类中使用，属性计算，属性观察\nclass Person\n{\n    private var value:String = "value"\n    \n    var name:String\n    {\n        set//只读属性即把set去掉就行\n        {\n            value = newValue\n            print("set - " + newValue)\n        }\n        get\n        {\n            return "get - " + value\n        }\n    }\n    //在类中使用，属性观察\n    var age:Int = -1\n    {\n        willSet\n        {\n            print("newValue = " + String(newValue))\n        }\n        didSet\n        {\n            print("oldValue = " + String(oldValue))\n        }\n    }\n}\n \nvar person = Person()\n \nperson.name = "hello"\nprint(person.name)\nperson.age = 18\n/*\nset - hello\nget - hello\nnewValue = 18\noldValue = -1\n */\nprint(" - - -- - - - - - - - ---  - - -- -  -  -= -=   =-  -= - =- = -= - =- = -=  ")\n//下标语法\nclass Data\n{\n    private var array1:[String] = ["Apple","Google"]\n    private var array2:[String] = ["android","ios"]\n    \n    //使用下标\n    //可以使用多个参数\n    subscript(index1:Int, index2:Int) -> String\n    {\n        //用不上set所以没有写\n\n        get\n        {\n            return array1[index1] + "-" + array2[index2]\n        }\n    }\n}\n \nvar data = Data()\nprint(data[0,1])//第一个的第二个\nprint(data[1,0])//第二个的第一个\n\n \n/*\nApple-ios\nGoogle-android\n*/\n
	第二十八节课
		//Any和AnyObject
			import Cocoa\n//Any和AnyObject\n        //Any可以表示任何类型（包括类的一个类型）\n            //Anyobject只能表示类的一个类型\n\n \nclass Person\n{\n    var name:String\n    \n    init(name:String)\n    {\n        self.name = name\n    }\n}\n \nstruct Data\n{\n    var data:String\n    \n    init(data:String)\n    {\n        self.data = data\n    }\n}\n//所有基础数据类型都属于Any（会进行 类型推断）\nvar a:Any = 1\nprint(type(of: a))\nvar b:Any = true\nprint(type(of: b))\nvar c:Any = [1,2,3,]\nprint(type(of: c))\nprint(" - - - - - - --  - - - - - - - - -")\nvar d:Any = Person(name: "sswift")\nvar e:Any = Data(data: "swiftt")\nprint()\n//var f1:AnyObject = Data(data: "报错")\nvar f:AnyObject = Person(name: "不报错")\nprint(type(of: f))\n//在面向对象中，子类类型的一个对象可以赋值给父类类型的一个引用（多态）（继承，封装，多态）\n
				Int\nBool\nArray<Int>\n - - - - - - --  - - - - - - - - -\n\nPerson\n
	第二十九节课
		//类的继承
			import Cocoa\n//类的继承\n//swift是一个单继承关系，和多协议（多接口）\n\nclass Person//定义一个父类\n{\n    private var name:String\n    private var age:Int\n    \n    init(name:String,age:Int)\n    {\n        self.name = name\n        self.age = age\n    }\n    \n    public func setName(name:String)\n    {\n        self.name = name\n    }\n    public func getName() -> String\n    {\n        return self.name\n    }\n    \n    public func setAge(age:Int)\n    {\n        self.age = age\n    }\n    \n    \n    public func getAge() -> Int\n    {\n        return self.age\n    }\n}\n   //如何继承Person()类\nclass Student:Person  //写法就是子类 冒号：父类\n{\n    func play(param:String)  //子类自己的新方法\n    {\n        print(param)\n    }\n}\n//创建父类实例per\nvar per = Person(name: "person", age: 10)\nprint(per.getName())\nprint(per.getAge())\nper.setAge(age: 100)\nprint(per.getAge())\nprint("----------------------")\n//创建子类实例stu\nvar stu = Student(name:"student",age:18)\n//stu的功能都继承自Person\nprint(stu.getName())\nprint(stu.getAge())\nprint(stu.play(param: "student play"))\n
	第三十节课
		向下类型转换（上节课的一个延续）
			//向下类型转换\n\nvar student:Person = Student(name:"student",age:18)\nprint(student.getAge()) //没有问题，因为这个getAge()在父类中有\n//这样定义student完全没有问题，因为Student类是Person的子类\n \nvar student2:Any = Student(name:"student",age:18)\n//print(student2.getAge())\n//有问题，因为这个getAge()在Any中没有\n//报错Error：Value of type 'Any' has no member 'getAge'\n \n//is 测试  |||||  (在Java中是IS-A测试)\nprint(student is Student)\nprint(student is Person)\nprint("------------------------")\n//向下类型转换，可选类型问题\nvar s = student as? Student//因为不知道s能不能转换为Stude类型\n//print(s.getAge())\n//报错Error Value of optional type 'Student?' must be unwrapped to refer to member 'getAge' of wrapped base type 'Student'\n\n//1 因此如果 明确知道可以转成Student类型，那就 直接解析：\nvar s2 = student as! Student\nprint(s2.getAge())\n//不会报错了\nprint("------------------------")\n \n//2 若不明确是否能转成Studen类型：法一\nvar s3 = student as? Student\nprint(s3?.getAge())\nprint(s3!.getName())\nprint("------------------------")\n \n//3 若不明确是否能转成Studen类型：法二：  可选项绑定\nif let s4 = student as? Student\n{\n    print(s4.getAge())\n    print(s4.getName())\n}\n/*\n //接过\nstudent\n18\nstudent play\n----------------------\n18\ntrue\ntrue\n------------------------\n18\n------------------------\nOptional(18)\nstudent\n------------------------\n18\nstudent\n*/\n
	第三十一节课
		重载
			import Cocoa\n//当两个函数名后者两个方法名相同的时候怎么去区分的作用\n//改变一些函数里的一些任意的东西即可\n \n//class Student0\n//{\n//    func play(param:String)\n//    {\n//        print(param)\n//    }\n//    func play(param:String)\n//    {\n//        print(param)\n//    }\n//}\n//报错Error\n \n//若有两个方法的名称参数完全一样，则会报错，因此必须使之至少一个不一样，\n//比如   参数不一样\nclass Student1\n{\n    func play(param:String)\n    {\n        print(param)\n    }\n    func play(param:Int)\n    {\n        print(param)\n    }\n}\n//   参数个数   不一样\nclass Student2\n{\n    func play(param:String,param2:Int)\n    {\n        print(param)\n    }\n    func play(param:String)\n    {\n        print(param)\n    }\n}\n//多个参数   顺序不一样\nclass Student3\n{\n    func play(param:String,param2:Int)\n    {\n        print(param)\n    }\n    func play(param2:Int,param:String)\n    {\n        print(param)\n    }\n}\n//参数  名称不一样\nclass Student4\n{\n    func play(param:String)\n    {\n        print(param)\n    }\n    func play(param2:String)\n    {\n        print(param)\n    }\n}\n//   返回类型不一样\nclass Student5\n{\n    func play(param:String) -> String\n    {\n        return ""\n    }\n    func play(param:String) -> Int\n    {\n        return 123\n    }\n}\n
	第三十二节课
		1 -重写方法；2 -final禁止继承重写
			import Cocoa\n//1 -重写\n//重写需要改变量范围，open>public>internal>fileprivate>private\n\n//private的范围太窄，需要扩大范围，其中internal是默认的选项，如果不写默认就是internal\n\n//重写的时候需要用override关键词进行变量或者函数重写\n\n// 有setter需要有getter，但有getter不一定要有setter-Variable with a setter must also have a getter\n\n// 以前的父类的方法该是什么就是什么，子类就是要override，进行改变\n\n//32 -重写\n\n \n\n//定义一个父类\n//重写需要改变量范围：\n//open  >  public  >  internal(默认) >  fileprivate   >  private\nprint(" - - -  - -- - - - - - -  - - - - - - ")\nclass Person\n{\n    var name:String\n    private var age:Int\n    \n    init(name:String,age:Int)\n    {\n        self.name = name\n        self.age = age\n    }\n    \n    public func setName(name:String)\n    {\n        self.name = name\n    }\n    public func setAge(age:Int)\n    {\n        self.age = age\n    }\n    \n    public func getName() -> String\n    {\n        return self.name + "person"\n    }\n    public func getAge() -> Int\n    {\n        return self.age\n    }\n}\n//如何继承Person()类：\n//     重载变量\nclass Student: Person      //写法就是子类 冒号：父类\n{\n    override var name:String//override表示重写 ，（Java中用“@override” 表示重写）\n    {\n        set\n        {\n            super.name = super.name + " set student" + newValue\n        }\n        get\n        {\n            return super.name + " get student"//super为父类的东西\n        }\n    }\n    override init(name: String, age: Int)\n    {\n        super.init(name: name, age: age)\n        self.name = name\n    }\n}\n \n \nvar per  = Person(name:"小A",age : 100)\nprint(per.name)\n \nvar stu = Student(name:"小B",age:126)\n \nprint(stu.name)\n//\nprint("- - - - -  - - - - -  - - - - - - - -  - - - - --- - - - - -  - - - --  - - - -  --")\n//重载函数\n           //没有重写就没有多态\nclass Student1:Person  //写法就是子类 冒号：父类\n{\n    override init(name: String, age: Int)\n    {\n        super.init(name: name, age: age)\n        self.name = name\n    }\n    \n    override func getName() -> String\n    {\n        return super.getName() + " - student"\n    }\n}\n \n \n \nvar stu1 = Student(name:"xiaoC",age:16)\nprint(stu1.getName())\n \nstu.setName(name: "set name")\nprint(stu.getName())\n//3 - final\n//final 禁止继承重写\n\nfinal class Person2//person2类就没有子类了，准确说是不能有子类了\n{\n}\n
	第三十三节课
		//关于计算属性，属性观察，下标的继承和重写
			import Cocoa\n//关于计算属性，属性观察，下标的继承和重写\n//都是如果子类不重写直接使用父类的方法就行，如果子类要重写使用override重写就行\n//1.继承下标\n\nclass Person\n{\n    var array:[String] = ["swift","ios"]\n    \n    subscript(index:Int) -> String\n    {\n        set\n        {\n            \n        }\n        get\n        {\n            return array[index]\n        }\n    }\n    init()\n    {\n        \n    }\n}\n \nclass Student:Person\n{\n    \n}\n \nvar student = Student()\n \nprint(student[0])\nprint(student[1])\n\n//2.重写下标\n\n \nclass Person1\n{\n    var array:[String] = ["swift","ios"]\n    subscript(index:Int) -> String\n    {\n        set\n        {\n            \n        }\n        get\n        {\n            return array[index]\n        }\n    }\n    init()\n    {\n        \n    }\n}\n \nclass Student1:Person1\n{\n    override subscript(index:Int) -> String\n    {\n        set\n        {\n            \n        }\n        get\n        {\n            return "override - " + super[index]\n        }\n    }\n}\n \nvar student1 = Student()\n \nprint(student1[0])\nprint(student1[1])\n\n
	第三十四节课
		关于多态调用属性和方的问题
			import Cocoa\n//多态调用属性和方法的问题\nclass A\n{\n    var name:String\n        init(name:String)\n            {\n            self.name = name\n        }\n    func printName() -> Void {\n        print("this is A " + name)\n    }\n    \n}\nclass  B: A {\n    \n}\n\nvar s1:A = A(name: "a")\nprint(s1.name)\ns1.printName()\n\nvar s2:A = B(name: "b")//父类类型的引用指向子类类型的对象（多态）\nprint(s2.name)\ns2.printName()\n//重写(在子类中重写父类的方法)\nprint(" -  -  - - - - - - - - - - - - - - - -  - - - - ")\nclass B1:A\n{\n    override func printName() {\n        print("this is B " + name)\n    }\n    func play() -> Void {\n        print("this is play")\n    }\n    \n}\nvar s11:A = B1(name: "a")\nprint(s11.name)\ns11.printName()\n//强制类型转换\nvar  s3 = s11 as! B1\ns3.play()\n\n\n
	第三十五节课
		类型判断处理，对象相等性判断
			import Cocoa\n//1 -类型判断和处理\nclass A{\n    \n}\nclass B:A {\n    var name:String\n    init(name:String) {\n        self.name = name\n    }\n    func printName() -> Void {\n        print("this is B name  = " + self.name)\n    }\n    \n}\nclass C:A {\n    var name:String\n    \n    init(name:String) {\n        self.name = name//需要实例化否则会报错\n    }\n    func printName() -> Void {\n        print("this is C name  = " + self.name)\n    }\n    \n}\nfunc getObject(parma:Int) -> A {\n    if parma>10 {\n        return B(name: "小B")\n    }\n    else{\n        return C(name: "小C")\n    }\n}\nvar obj = getObject(parma: 15)\nvar t:A = B(name: "实际是A类型")\nprint(type(of: obj))\n//向下类型转换(is   as!)\nif(obj is B)\n{\n    var p = obj as! B\n    p.printName()\n}\nelse{\n    var p = obj as! C\n    p.printName()\n    \n}\n//可选项转换\n\nif let t1 = obj as? B\n{\n    t1.printName()\n}\nelse if let t2 = obj as? C\n{\n    t2.printName()\n}\n\n\n\n\n\nprint(" - - - -- - -  - - -- - - - -  - - - - - - ")\n//2 -对象相等性判断\nclass A1\n{\n    \n}\nvar t1 = A1()\nvar t2 = A1()//只要初始化就是创建了一个新的对象\nprint(t1 === t2)\n//因为类传递的是引用，t1和t2是两个不同的类\nprint(t1 !== t2)\nvar t3 = t1\n//因为传递引用的都是t1在定义时的类的对象，t1和t3引用的是同一个对象\nprint(t3 === t1)\n
	第三十六节课
		扩展extension，泛型
			import Cocoa\n//1 -扩展extensiojn；\nclass A\n{\n    \n}\nextension A\n{\n    var name:String\n    {\n        get\n        {\n            return "hello world"\n        }\n    }\n    \n    static func toString()//static 类方法\n    {\n        print("this is A toString")\n    }\n}\nvar a = A()\nA.toString()\n//也可以对现有类型进行扩展\nextension String\n{\n    func toString() -> String {\n        return "长度 = " + String(self.count)\n        \n    }\n}\nvar  s:String = "asdfghjkl"\n\nprint(s.toString())\n\n//如果将toString定义为静态函数也，也可以直接用类名A.toString()\n//2 -泛型；\nfunc toString1<T>(parma:T) -> T //类型是T，参数类型是T，返回T类型，T是一个不确定的类型\n{\n    return parma\n}\n//因此可以传入任意类型(包括基本数据类型，数组，元祖等等。。。。)\nprint(toString1(parma: "hello"))\nprint(toString1(parma: 1))\nprint(toString1(parma: 1.22))\nprint(toString1(parma: [1,2,3]))\n\n//数组泛型\nvar array:Array<Int> = [1,2,3]\nprint(array[2])\n
	第三十七节课
		协议protocol
			import Cocoa\n\n//协议protocol （Java接口interface） 主要描述属性或方法规定的一个样子（抽象）\n\n//协议protocal，相当于API\nclass TestClass\n{\n    \n}\nprotocol Protocol1 {\n    var value1:String {set get}\n    func paly1() -> String\n    \n}\nprotocol Protocol2 {\n    var value2:String {get}//翻译：只读属性\n    func paly2() -> String\n    \n}\nclass Data:TestClass,Protocol1,Protocol2//Data就是实现类\n{\n    var value1: String\n    var value2: String\n    {\n        get\n        {\n            return value2//只有get（即只有可读属性就不需要写get）但是具体是否可读可写有Data实现类来决定\n        }\n    }\n    func paly1() -> String {\n        return self.value2\n    }\n    func paly2() -> String {\n        return self.value2\n    }\n    init(value1:String)//用init来初始化\n    {\n        self.value1 = value1\n    }\n    \n}\nvar daat = Data(value1: "hello")\nprint(daat.paly1())\nprint(daat.paly2())\n\n
	第三十八节课
		延迟属性lazy
			import Cocoa\n//延迟属性 (懒加载)（节省空间）\nclass Data\n{\n    init() {\n        print("Data init")\n    }\n    func play()  {\n        print("Data play")\n    }\n}\nclass Test {\n  lazy  var data:Data = Data()//初始化\n    init() {\n        print("Test init")\n    }\n}\nvar test = Test()\n/*\n 成员变量先初始化\n Data init\n Test init\n*/\ntest.data.play()//延迟变量实例化\n
	第三十九节课
		//1 -普通初始化器\n//2 -可失败初始化器\n
			import Cocoa\n//1 -普通初始化器\nclass TEst\n{\n    var name:String\n    init(name:String)\n    {\n        self.name = name\n    }\n    \n}\nvar t = TEst(name: "hello")\nprint(t.name)\n//2 -可失败初始化器 (init?)加个问号\nclass Test\n{\n    var name:String\n    init?(name:String)\n    {\n        if name == "unkonw" {\n            return nil\n        }\n        self.name = name\n    }\n    \n}\nvar t1:Test? = Test(name: "hello")\n//Test类型的可选类型（可能为空可能有值）\n/*if t1 == nil {\n    print("初始化失败")\n}*/\nif let p = t1\n{\n    print(p.name)\n}\nelse\n{\n    print(t1!.name)\n}\n
	第四十节课
		//1 -必要初始化器required\n//2 -结构体成员初始化器\n//3 -闭包设置属性初始值
			import Cocoa\n//1 -必要初始化器required（父类有一个required的初始化器init(),那么子类也需要。）\n//子类重写的时候，不必写override，直接写requeird关键字\nclass Tets\n{\n    var name:String\n    required init(name:String)\n    {\n        self.name = name\n    }\n    \n}\nclass T: Tets {\n    required init(name: String)\n    {\n        super.init(name:name)//先初始化父类\n    }\n}\nvar t = T(name: "hello")\nprint(t.name)\n//2 -结构体成员初始化器\nstruct Test1\n{\n    var name:String\n    var age:Int\n    /*结构体默认有一个默认初始化器\n//    init(name:String,age:Int)\n//    {\n//        self.name = name\n//        self.age = age\n//    }*/\n}\n \nvar t1 = Test1(name:"hello",age:10)\nprint(t1.name) //即，初始化器上面的部分是默认的的，有或没有都可以调用\nprint(t1.age)\n \n//但是类和结构体不一样，类一定要有初始化器\n//因此如果在结构体里没有什么需要做的事情，完全可以把类变成初始化器\n\n\n//3 -闭包设置属性初始值    var xxx = {xxx}()\n//闭包是匿名函数吗？？？？？？？\n\nclass Test3\n{\n    var name:String = {return "swift"}()\n        var age:Int =  //闭包设置属性，也可以在初始化器里面设置\n        {\n            var a = 10\n            var b = 20\n            \n            return a+b\n        }()\n        \n        init(name:String,age:Int)\n        {\n            self.name = name\n            self.age = age\n        }\n}\n \nvar t3 = Test3(name:" test3 " ,age:100 )\nprint(t3.name)\nprint(t3.age)\n\n
	第四十一节课
		//1 -自动引用计数ARC工作机制\n\n//2 -强引用\n//3 -反初始器\n
			import Cocoa\n\n//1 -自动引用计数ARC工作机制（析构函数）\n\nclass Tets\n{\n    var name:String\n    init(name:String) {\n        self.name = name\n    }\n    \n}\n     //拷贝构造函数\nvar t1:Tets = Tets(name: "heelo")//引用类型的变量，可以指向一个对象\nvar t2 = t1\nvar t3 = t2\nt3.name = "asdfghjkl"\n//这样的话t1 t2 t3 同时指向同一个对象\nprint(t1,t2,t3)//t1---t3引用一样\nprint(t3.name)\n\n//ARC工作机制\n\n//如果没有任何引用指向Test实例的时候，那么这个实例对象会自动销毁，该实例被释放\n\n\n\n\n//2 -强引用\n//只要有一个引用指向Test，那么Test就不会被销毁，除非全部断开，没有一个引用指向Test对象\n\n\n\n\n\n\n//3 -反初始器\n//\n//当一个实例对象（Test）被销毁的时候，就会调用反初始化器\n//oc的dealloc\nprint(" - - -   -  --  --  -- -  -- - - -  --  -- - - - -  --  -- -  - --- ")\nclass Test1\n{\n    var name1:String\n    init(name1:String)\n    {\n        self.name1 = name1\n    }\n    \n    deinit\n    {\n        print("Test被销毁 - " + self.name1)\n        \n    }\n}\n \nvar t11:Test1? = Test1(name1:"hello")\n \nt11 = nil\nvar t:Test1? = Test1(name1: "world")\nt = nil\n
	第四十二节课
		循环强引用
			//1 -循环强引用\n//循环强引用就是断开了直接的引用但是内部仍然存在相互引用。\n//\n//在没有循环强引用下：被注释掉\nclass TestA\n{\n    var name:String\n    var ref:TestB?  = nil\n    \n    init(name:String) {\n        self.name = name\n    }\n    deinit {\n        print("TestA的实例被释放 - " + self.name)\n    }\n}\nclass TestB  {\n    var name:String\n    var ref:TestA?  = nil\n    init(name:String) {\n        self.name = name\n    }\n    deinit {\n        print("TestB的实例被释放 - " + self.name)\n    }\n}\n\n//首先想让变量为空，应该为可选类型\nvar testA:TestA? = TestA(name: "A")\n//print(testA.name)\nvar testB:TestB? = TestB(name: "B")\n//print(testB.name)\ntestA!.ref = testB//内部属性互指\ntestB!.ref = testA\n//取消注释之后，引发内部循环调用：\n//\n//取消实例引用后，无法调用方法和属性\n\ntestA = nil\ntestB = nil//引用都与实例断开了（节约内存）\n\nvar testAA:TestA? = TestA(name:"A")\n \nvar testBB:TestB? = TestB(name:"B")\n\ntestAA!.ref = testB\ntestBB!.ref = testA\n \ntestAA = nil\ntestBB = nil\n//无返回值\n
		弱引用
			//2 -弱引用weak  弱引用不会增加引用计数\n//弱引用就是TestA与TestB之间的引用不会影响ARC机制，强引用会影响，阻止回收，导致无法释放。\n//\n//即释放的两种方法：\n//1.变成弱引用;\n//2.直接断开，令之为nil，注意nil的前提是可选类型\n\n//弱引用weak， 加关键字weak\nclass TestA\n{\n    var name:String\n    var ref:TestB? = nil\n    init(name:String)\n    {\n        self.name = name\n    }\n    \n    deinit\n    {\n        print("TestA的实例被释放 - " + self.name)\n    }\n    \n}\nclass TestB\n{\n    var name:String\n    weak var ref:TestA? = nil  //弱引用加关键字weak\n     var ref2:TestA? = nil\n    init(name:String)\n    {\n        self.name = name\n    }\n    \n    deinit\n    {\n        print("TestB的实例被释放 - " + self.name)\n    }\n}\n \nvar testA:TestA? = TestA(name:"A")\n \nvar testB:TestB? = TestB(name:"B")\n \n \n//循环强引用\ntestA!.ref = testB\ntestB!.ref = testA\ntestB!.ref2 = testA\n \n//testA!.ref = nil\ntestB!.ref2 = nil\ntestA = nil\n \n/*\nTestA的实例被释放 - A\n*/\n
	第四十三节课
		无主引用unowned
			强引用，只有testA指向TestA
			先释放TestB
			import Cocoa\n//首先都是强引用，然后实例化属性ref\n      //只要有强引用存在，对象就不会被销毁\n//无主引用\nclass TestA\n{\n    var name:String\n    var ref:TestB? = nil\n    init(name:String)\n    {\n        self.name = name\n    }\n    \n    deinit\n    {\n        print("TestA的实例被释放 - " + self.name)\n    }\n    \n}\nclass TestB\n{\n    var name:String\n    var ref:TestA\n    init(name:String,ref:TestA)\n    {\n        self.ref = ref\n        self.name = name\n    }\n    \n    deinit\n    {\n        print("TestB的实例被释放 - " + self.name)\n    }\n}\n//强引用，只有testA指向TestA\n//之后再逐一释放，麻烦\n \nvar testA:TestA? = TestA(name:"A")\n\n \ntestA!.ref = TestB(name: "B", ref: testA!)\n \ntestA!.ref = nil //这一步就没有指向TestB的强引用了，TestB被释放\n \ntestA = nil\n
	第四十四节课
		闭包循环引用，定义捕获列表
			import Cocoa\n\n//1 - 闭包循环引用  （匿名函数 属性）\n//把闭包赋给一个变量，那么这个变量就相当于一个函数，可以来使用\n//类似oc的 block内部对self造成了强引用\nclass Test\n{\n    var name:String\n   lazy var data:() -> Void = {() -> Void in\n        print("姓名： = " + self.name)\n    //延迟初始化，保证安全性\n    }\n//    闭包持有引用，而Test的data指向了闭包\n//    闭包中的self指向了当前的t实例（你只有我，我中有你），像OC里的block中调self.\n    init(name:String) {\n        self.name = name\n    }\n    deinit {\n        print("Test的实例被释放 - " + self.name)\n    }\n}\nvar t:Test? = Test(name:"hello")\nt!.data()\nt = nil\n//2 - 定义捕获列表\n//像OC里的__weak typeof(self) weakSelf = self\n//1.用无主引用\n//定义捕获列表\nclass Test1\n{\n    var name:String\n    //1-加入一个列表\n    lazy var data:() -> Void = {[unowned self]() -> Void in //2-给匿名函数传入一个无主引用的对象\n        print(self.name)\n        \n    }\n    \n    init(name:String)\n    {\n        self.name = name\n    }\n    \n    deinit{\n        print("Test的实例被释放 - " + self.name)\n    }\n    \n}\n \nvar t1:Test? = Test(name:"hello")\n \nt1!.data()\nt1 = nil\n//被释放掉了\n \n/*\nhello\nTest的实例被释放 - hello\n*/\n//2.或者用弱引用\n//(有时候会没有值)   ---  --  - - - -  （一般用无主引用比较好）\n\n\n//定义捕获列表\nclass Test2\n{\n    var name:String\n    //1-加入一个列表\n    lazy var data:() -> Void = {[weak self]() -> Void in //2-给匿名函数传入一个无主引用或者weak引用的对象\n        print(self!.name) //注意weak引用可能没值，所以要加！号\n        \n    }\n    \n    init(name:String)\n    {\n        self.name = name\n    }\n    \n    deinit{\n        print("Test的实例被释放 - " + self.name)\n    }\n    \n}\n \nvar t2:Test? = Test(name:"hello")\n \nt2!.data()\nt2 = nil\n//被释放掉了\n/*\nhello\nTest的实例被释放 - hello\n*/\n \n
	第四十五节课
		可选链展开
			import Cocoa\n//可选链展开\n\nclass Data\n{\n    var name:String\n    init(name:String)\n    {\n        self.name = name\n    }\n    func play()\n    {\n        print(self.name)\n    }\n}\n \nclass Test\n{\n    var name:String\n    var data:Data? = nil//可选类型才能设置为空\n    \n    init(outname name:String,data:Data) //将Data的一个实例化对象传到Test的初始化器里面去\n    {\n        self.name = name\n        self.data = data\n    }\n    deinit//反初始化器\n    {\n        print("Test的实例被释放 - " + self.name) //反初始化器\n    }\n}\n \nvar t:Test? = Test(outname:"hello",data:Data(name:"world"))\n \n//Data(name:"AAA").play()  直接调用方法，没有变量接收\n \n//t!.data?.play()\n(t!.data)?.play()//强行解包\n(t?.data)?.play()//一旦遇到空，就调用是失败，并且不会报错\n\n//可选链展开应该就是最后的！和？的选择，如果不确定有没有值，用？不会报错，但如果是nil，用！的话会报错\n\n/*\nworld\n*/\n
	第四十六节课
		尾随闭包 闭包是可以在你的代码中被传递和引用的功能性独立代码块。Swift 中的闭包和 C  以及 Objective-C 中的 blocks 很像，还有其他语言中的匿名函数也类似。\n\n闭包能够捕获和存储定义在其上下文中的任何常量和变量的引用，这也就是所谓的闭合并包裹那些常量和变量，因此被称为“闭包”，Swift 能够为你处理所有关于捕获的内存管理的操作。
			import Cocoa\n//尾随闭包（一些简写方式） |||| （函数类型的参数一定要在参数列表的最后一位）\nfunc play1(parma1:String,parma2:(String) -> Void)\n{\n    parma2(parma1 + " - swift")\n}\nplay1(parma1: "hello", parma2: {(data:String) -> Void in\n    print(data)\n})//现在还不是尾随闭包\nplay1(parma1: "world") { (daat:String) -> Void in\n    print(daat)\n//最后一个参数是函数 (在小括号外面)\n}\nprint(" - - --  ---  - - - - --  - - - - --  -")\n//参数列表只有一个参数还是可以用尾随闭包\nfunc play2(parma:(String) -> String)\n{\n    var value =   parma("swift")\n  print("返回值 = " + value)\n}\nplay2(parma: {(data:String) -> String in\n    return data + " - ios"\n})\n////参数是函数 (在小括号外面)\nplay2(parma: {(data:String) -> String in\n    return data + " - macos"\n})\nplay2{(p) -> String in\n    return p + " - apple"\n}\nprint(" - - --  ---  - - - - --  - - - - --  -")\nfunc play3(param:() -> Void)\n{\n    param()\n}\n \nplay3(param:{() -> Void in\n    print("play3")\n})\n// 可以不要\nplay3{\n    print("play3")\n}\nprint(" - - --  ---  - - - - --  - - - - --  -")\n\nfunc play4(param:() -> String)\n{\n    var value = param()\n    print("value = " + value)\n}\n \nplay4(param:{() -> String in\n    return "hello world"\n})\n \nplay4(){() -> String in\n    return "hello world"\n}\nplay4{() -> String in\n    //前面没有参数，（）可以去掉\n    return "hello world"\n}\nplay4{\n    //有return，一堆可以去掉\n    return "hello world"\n}\nprint(" - - --  ---  - - - - --  - - - - --  -")\n//不是尾随闭包\nfunc play5(param1:(Int) -> Void,param2:Int)\n{\n    param1(param2 * 2)\n}\n// 现在就不能用尾随闭包，因为参数列表以后一位不是函数类型\nplay5(param1:{(data:Int) -> Void in\n    print(data)},\n      param2: 100)\n \nplay5(param1:{(data)in//类型推断\n    print(data)\n},param2: 100)\n
	第四十七节课
		// 错误捕获和处理（异常处理
			import Cocoa\n// 错误捕获和处理（异常处理）\nenum TestError:String,Error\n{\n    case error1 = "错误1"\n    case error2 = "错误2"\n    }\nfunc play(parma:Int)  throws -> String\n    {\n    if parma<0 {\n        throw TestError.error1\n    }\n    else if (parma >= 0 && parma <= 10)\n    {\n        throw TestError.error2\n    }\n    print("正常执行")\n    return "heelo world"\n}\n\n//错误捕获和处理（异常处理）\ndo\n{\n    var value =  try play(parma: 100)\n}\ncatch TestError.error1\n{\n    print(TestError.error1.rawValue)\n}\ncatch TestError.error2\n{\n    print(TestError.error2.rawValue)\n}\ndefer\n{\n    print("defer")\n}\nprint(" - - -  - -0 -- -  --  - - - - - - - - - --")\n//也可以把错误传成一个可选类型，进行返回\n//不同的情况下抛出不同的错误，但是我并不想知道具体错误，不管什么错误都是空就行\ndo\n{\n    var value = try play(param:100)  //接收一下\n    print(value)    //和do catch 没什么关系，放外面也可以\n}\ncatch TestError.error1\n{\n    print(TestError.error1.rawValue)\n}\ncatch TestError.error2\n{\n    print(TestError.error2.rawValue)\n}\ndefer\n{\n    print("defer")\n}\n\n
	第四十八节课
		//1-泛型类型限定；\n//2-协议关联类型
			import Cocoa\n//1-泛型类型限定\n\nclass Data\n{\n    var name:String\n    init(name:String) {\n        self.name = name\n    }\n    \n}\nfunc play<T:Any>(parma:T)\n{\n    var a = parma as! Data\n    //向下类型转换\n    \n    print(parma)\n}\n\nplay(parma: Data(name: "hello"))\n\n\n\n\n//2-协议关联类型\nclass Data\n{\n    var name:String\n    init(name:String)\n    {\n        self.name = name\n    }\n}\n \nprotocol Test\n{\n    associatedtype D  //定义了协议中的一个未知类型\n    func play(param:D)\n}\n \nclass Student:Test\n{\n    func play(param:String){\n        print(param)\n    }\n}\n \nvar s = Student()\ns.play(param: "没有定义D的类型，给play传一个字符串")\n\nclass Data\n{\n    var name:String\n    init(name:String)\n    {\n        self.name = name\n    }\n}\n \nprotocol Test\n{\n    associatedtype D: Data //定义了协议中的一个未知类型\n    func play(param:D)\n}\n \nclass Student:Test\n{\n    func play(param:Data){\n        print(param.name)\n    }\n}\n \nvar s = Student()\ns.play(param: Data(name: "swift"))
	第四十九节课
		//访问权限
			import Cocoa\n////访问权限\n\n//\n//1: private\n//\n//private访问级别所修饰的属性或者方法只能在当前类里访问。\n//\n//2: fileprivate\n//\n//fileprivate访问级别所修饰的属性或者方法在当前的Swift源文件里可以访问。\n//\n//3: internal (默认访问级别，internal修饰符可写可不写)\n//\n//internal访问级别所修饰的属性或方法在源代码所在的整个模块都可以访问。如果是框架或者库代码， 则在整个框架内部都可以访问，框架由外部代码所引用时，则不可以访问。如果是App代码,也是在整个App代码,也是在整个App内部可以访问。\n//\n//4: public\n//\n//可以被任何人访问。但其他module中不可以被override和继承，而在module内可以被override和继承。\n//\n//5: open\n//\n//可以被任何人使用，包括override和继承。\n
	第五十节课
		总结
目录
	p001--p050
		P1：数据类型、变量常量、类型判断、拼接字符串\n\n1.查看 swift 版本：终端输入 xcrun swift -version\n\n2.基础数据类型：Int,Float,Double,Bool,Character,String\n\n3.变量常量：var,let\n\n4.类型推断\n\n5.判断数据类型\n\n6.输出语句：print()\n\n7.拼接字符串：\()语法和+号语法\n\n8.注释\n\nP2：类型别名、类型转换\n\n1.类型别名\n\n2.类型转换\n\nP3:可选类型和解析值\n\n1.Optional可选类型：var a:Int? = 10\n\n2.解析值\n\nP4：元组类型\n\n1.定义元组\n\n2.打印元组的值\n\n3.修改元组的值\n\n4.类字典索引\n\n5.对应值索引\n\nP5:基础运算符\n\n1.基本运算符\n\n2.比较运算符\n\n4.三元运算符(a为真取b值，a为假取c值）\n\n5.合并空值运算符（取可选类型的值)\n\n6.区间运算符（很重要）\n\n7.其他操作说明\n\n8.运算符优先级\n\nP6: if 语句、可选项绑定、隐式展开\n\n1.if 语句\n\n2.可选项绑定\n\n3.隐式展开\n\nP7：switch case 和 fallthrough穿透效果\n\n1.switch case （默认没有穿透效果）\n\n2.fallthrough穿透效果\n\nP8：区间运算符、for in 循环、continue 和 break\n\n1.区间运算符\n\n2.for in 循环\n\n3.continue 和 break（和其他编程语言相同)\n\nP9：while 循环和 repeat while 循环\n\n1.while 循环\n\n2.repeat while 循环 （先运行再判断）\n\nP10：String 基础操作\n\n1.获取字符串长度\n\n2.获取子字符串\n\n3.其他常用操作\n\n4.遍历字符串\n\n5.格式化文本输出\n\n6.类转义输出\n\nP11：Array 数组\n\n1.数组的定义\n\n2.数组的基本操作\n\n3.数组排序\n\n4.数组过滤\n\n5.数组比较\n\n6.遍历数组\n\nP12：Set 集合\n\n1.集合的定义\n\n2.集合常用操作\n\n3.集合相等判断\n\n4.集合过滤\n\n5.遍历集合\n\nP13：Dictionary 字典\n\n1.字典的定义\n\n2.字典的基本操作\n\n3.字典过滤\n\n4.遍历字典\n\nP14：函数定义、函数参数名称、assert断言\n\n1.函数定义\n\n2.函数参数名称问题\n\n3.assert断言\n\nP15：guard 语句\n\n1.guard 语句\n\n2.guard 语句和 if 语句，在处理可选项绑定之间的区别比较\n\nP16：inout 关键字、函数类型\n\n1.inout 关键字\n\n2.函数类型\nP17：匿名函数作为函数的参数\n\n函数类型作为函数的参数类型\n\nP18：函数作为返回值，内嵌函数\n\n1.函数作为返回值\n\n2.内嵌函数\n\nP19：匿名函数的简写方式\n\nP20：定义枚举，设置枚举值\n\nP21：枚举相关值，遍历枚举\n\n1.枚举相关值\n\n2.遍历枚举\n\nP22：结构体定义使用\n\n1.结构体\n\n2.mutating关键字\n\n3.结构体实例也是值传递\n\n4.常量和变量实例\n\nP23：计算属性的使用\n\n1.计算属性set和get\n\n2.只读属性\n\nP24：属性观察的使用willSet和didSet\n\n属性观察\nP25：下标语法subscript\n\nP26：类的定义使用，类的实例是传引用\n\n1.定义和使用\n\n2.类的实例是引用\n\nP27：类中使用属性计算，属性观察，下标语法（前面已介绍过）\n\n1.属性计算、属性观察\n\n2.下标语法\n\nP28：Any和AnyObject类型\n\nP29：类的继承\n\nP30：向下类型转换（P29课的代码延续）\n\nP31：方法重载\n\nP32：重写方法，final禁止继承重写\nP33：属性计算观察和下标的继承和重写\n\n1.继承下标\n\n2.重写下标\n\nP34：多态调用方法和属性的问题\n\nP35：类型判断处理，对象相等性判断\n\n1.类型判断和处理\n\n2.对象相等性判断\n\nP36：扩展extension，泛型\n\n1.扩展extension\n\n2.泛型\n\nP37：协议protocol\n\nP38：延迟属性lazy\n\nP39：普通初始化器，可失败初始化器\n\n1.普通初始化器\n\n2.可失败初始化器\n\nP40：必要初始化器，结构体成员初始器，闭包设置属性值\n\n1.必要初始化器\n\n2.结构体成员初始器\n\n3.闭包设置属性\nP41：自动内存释放，反初始化器\n\n1.自动引用计数ARC工作机制\n\n2.强引用\n\nP42：循环强引用，弱引用weak\n\n1.循环强引用\n\n2.弱引用\n\nP43：无主引用unowned\n\n \n\nP44：闭包循环引用，定义捕获列表\n\n1.闭包循环引用\n\n2.定义捕获列表\n\nP45：可选链展开\n\nP46：尾随闭包\n\nP47：错误捕获和处理\n\nP48：泛型类型限定，协议关联类型\n\n1.泛型中的类型限定\n\n2.协议中的类型限定\n\nP49：访问权限简单说明\n\nP50：总结
